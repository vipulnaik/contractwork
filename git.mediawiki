This article explores the source code management and collaboration system called Git and provides guidance on how to get the most value from Git.

Git can be used as a local source code management system, and can also be used for collaboration across people and devices with a single central hub (called the origin, or sometimes the "remote origin").<ref name=origin>[http://stackoverflow.com/questions/9529497/what-is-origin-in-git What is “origin” in Git?]; as explained here, there is no canonical origin for a git repository, but in practice most use of Git for collaboration uses a single origin. More complex collaboration patterns are possible but generally unnecessary and undesirable for simple use cases.</ref> The term for a collection of files in Git is a "repository", and all Git operations are performed within a repository. Many people host their repositories at places such as GitHub, <ref>[http://www.howtogeek.com/180167/htg-explains-what-is-github-and-what-do-geeks-use-it-for/ HTG Explains: What Is GitHub and What Do Geeks Use It For?]</ref> Bitbucket,<ref>[https://www.atlassian.com/software/bitbucket Code, Manage, Collaborate. Bitbucket is the Git solution for professional teams]</ref> and Amazon Web Services CodeCommit.<ref>[http://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html What is AWS CodeCommit?]</ref> It is also possible to have a purely local Git repository (with no remote origin) or to host the remote origin on your own server.

This how-to guide focuses on the key concepts of Git, the main parts of the Git workflow, as well as the command-line tools needed in the usual course of operations (that you can use in a Linux or UNIX terminal, or with Git Bash if using Windows). There are many other online guides on using Git that focus on command-line tools as well as other aspects including migrating from other version control systems (such as SVN).<ref>[https://www.atlassian.com/git/ Getting Git Right]</ref><ref>[http://rogerdudler.github.io/git-guide/ git - the simple guide]</ref><ref name=seth>[https://sethrobertson.github.io/GitBestPractices/ Commit Often, Perfect Later, Publish Once: Git Best Practices]</ref> There are also guides focused on particular GUI Git tools as well as on using GitHub itself.<ref>[http://lifehacker.com/5983680/how-the-heck-do-i-use-github How the Heck Do I Use GitHub?]</ref> For basic guides on getting started with Git using GitHub, read the WikiHow pages on [[Create an Account on GitHub|creating a GitHub account]], [[Add SSH Public Keys on GitHub|adding SSH keys]], [[Create a Repository on GitHub|creating a GitHub repository]], and [[Set Up a Git Server with SSH on Windows|setting up a Git server with SSH on Windows]].

Git's chief use case is source code management. Its algorithm for merging changes (which is in some sense its main attraction, though you may still find it useful even if you rarely need to merge changes) relies heavily on reading files line by line. This works reasonably well for source code (with many caveats), but less well for other kinds of formats like PDFs, Word Documents, or executables. This is because source code generally tends to have large numbers of lines each of which is short, with natural line breaks.

== Steps ==
=== Understanding some basic Git terminology ===
# A "repository" is a collection of files that is the basic unit on which git operations are performed. Every git command operates on only one repository at a time.
#* On your machine, a repository includes a directory and all files in it and (recursively) in its subfolders.
#* It is possible to explicitly tell Git to ignore (i.e., not track) particular files or all files (recursively) inside a particular directory. The list of files and directories to exclude is in the .gitignore file. Files that are ignored will not be tracked with Git, and they may not be synced between different copies of the Git repository.
#* All copies of the same Git repository, when synced, should have the same subdirectories and files, excluding those that are marked with .gitignore. If you are using GitHub or Bitbucket, the files you see when browsing online, or the files you get when you first clone the repository, will not include any ignored files.
#* All git commands associated with a repository can be run from the command line (UNIX or Linux terminal or Git bash) from any folder within the repository. Being in the root folder of the repository is not necessary.
# The "remote origin" for your local Git repository is the place that you first cloned the Git repository from. By default, this is referenced as origin in various git commands, though you can change the name to something else.<ref name=origin/> In a typical collaborative Git setup, there is a single remote origin for all users (managed by GitHub, Bitbucket, or Git running on their server) and all synchronization happens through that remote origin, i.e., each collaborator pushes to and pulls from that remote origin, rather than directly to another collaborator. Note, however, that it is possible to have a different architecture.
# A few other key terms (that will be explained with more context later):
#* A "commit" is a checkpoint of a complete state of the Git repository. Each commit has a unique identifier and it is possible to revert to any commit. Each commit includes a commit time, a committing user, and optionally, a commit message (that should ideally describe the most recent changes included in the commit).
#* A "branch" can be thought of as a version of the Git repository. The default branch is called "master". At any point, a new branch can be created cloning the existing state of the Git repository. The branches can subsequently diverge. One can switch between branches, and one can eventually merge branches.
#* The term HEAD is used for the most recent commit. In each repository, each branch has a HEAD.
#* The "status" of the repository provides information on the current branch, what changes may have been made that are not committed, and whether the changes are synced with the remote origin. If there are no uncommitted changes, then git considers the status to be clean (another way of saying this is that the branch is at its HEAD). A clean status reports an empty result when you run <tt> git status --porcelain</tt>. Note that changes to files marked to be ignored are not considered when reporting the status.
=== Understanding the three main uses of Git ===

# The first use case for Git is as a way of periodic checkpointing through commits.<ref>[http://gitref.org/index.html Introduction to the Git Reference] says: "This is essentially what Git is. You tell Git you want to save a snapshot of your project with the git commit command and it basically records a manifest of what all of the files in your project look like at that point. Then most of the commands work with those manifests to see how they differ or pull content out of them, etc."</ref>
#* Each git commit creates a checkpoint that you can revert to at a later stage if you discover subsequent problems. In this respect, Git is a substitute for version control systems like Subversion, with the key distinction that whereas SVN operates at the level of individual files, Git operates at the level of the repository.
#* The most relevant git commands here are <tt>git stage</tt> (synonymous to <tt>git add</tt>) and <tt>git commit</tt>. 
#* Other related commands are <tt>git reset</tt>, <tt>git mv</tt>, and <tt>git rm</tt>.
#* You can see the full commit history using <tt>git log</tt>.

# The second use case for Git is working with multiple branches.
#* It is possible to create multiple branches of your repository where you work on different changes. 
#* The most relevant commands for creating and switching between branches are <tt>git branch</tt> and <tt>git checkout</tt>. 
#* The relevant command for reconciling changes between branches is <tt>git merge</tt> (more generally, <tt>git merge</tt> can be used to try to merge any two commits, and the commits at the HEAD for two different branches are a natural candidate for things to merge).

# The third use case for Git is collaborating across different devices and users, possibly including a web-based access from the remote origin.
#* To push changes from your local repository to the remote origin, use git push. 
#* To get changes from the remote origin into your local repository, use git fetch (this simply fetches the changes) or git pull (this fetches and merges the changes in).
#* The "collaboration" you get in Git is conceptually quite different from the kind of collaboration you get with tools like Google Docs or Hackpad. The latter emphasize real-time collaboration where participants are usually online and editing simultaneously, with a single global state of the document at all times. Git, on the other hand, works on a model of ''offline'' changes that are then ''merged'' (if two different users make changes separately from the same starting point).
#* Git is more similar to Dropbox, in the sense that in both, there are local copies that can be edited offline, and there is a step of syncing the local copy to the remote origin (if a user is online and has Dropbox running then the changes will be made in real time). However, Dropbox does not handle multiple people editing the same file offline well, because it does not have a method of merging changes within a single file. Git's ability to merge changes ''within a single file'' is crucial to its usefulness for source code management.

# The three uses of Git are somewhat conceptually intertwined.
#* '''Branching and merging depends somewhat on committing''': Without clear checkpoints recording particular states of the repository, branching would be hard to manage.
#* '''Collaboration and branching share reliance on the ability to merge''': The ability to merge changes, whether between different branches in a local repository, or within the same branch but between the local repository and remote origin, is a critical part of Git's utility.

# It is possible to take advantage of only one or two of the three things it's designed for.
#* Only (1): Git can be used purely as a checkpointing system for a linear (sequential) workflow. Changes are made in a particular sequence and the state is recorded periodically through commits. This makes it easy to, if neecessary, revert to a previous commit and start afresh from there, while expecting this to be a rare occurrence. This use case is most common for a single user working on a single file.
#* Only (2): Git can be used primarily as a way of handling cases where you want to work on two different changes in parallel, without letting them interfere with one another, and merge when they are completed. If using Git this way, you would commit ''only'' when you want to start branching, when you are switching between branches, and when you are finished with work on the branches and want to merge.
#* Only (3): Git can be used primarily as a way of transferring files between different devices you may be working on, plus keeping a remote backup. In this case, you commit ''only'' when you wish to push to the remote, which you do either when you wish to back up the files or when you are switching devices or handing over the work to another user. Here, the primary advantage of Git is that it's easier and faster than emailing files over, particularly if you are working on the same repository repeatedly but have a large and/or regularly changing set of files.
#* (1) and (2): Git can be used as a system for checkpointing and branching/merging for a single user. The remote origin plays no particular role (and there may not even be a remote origin!).
#* (1) and (3): Git can be used as a system for checkpointing and for collaborating across multiple users (e.g., one user works on the code in one timezone, then hands it off to the other user who works in another timezone).
#* (2) and (3): Git can be used primarily for branching and collaboration, with infrequent checkpointing.
# A general best practice guideline for Git is that it should ''always'' be used for at least (1) even if that is not the primary reason one is using Git. In other words, it is good to ''commit often''. This is because the benefits of having checkpoints are significant, and the costs are negligible. Whether and how to use (2) and (3) (in particular, whether it's a good idea to push frequently, and whether it's a good idea to branch out regularly instead of working from master) generally depends on workplace best practices and your particular use case.<ref name=seth/> The one main counterpoint is that once a change has been committed, it is very hard to permanently erase it from the Git repository. Therefore, ''never'' commit any changes that have sensitive information in them that you might later regret other people finding out.

=== Mastering the save-stage-commit-push workflow ===

# The way to make changes in the Git repository is to save, (stage-and-commit), and push. Of these, the saving step is something you handle through your editor or IDE (i.e., the same methods that you would otherwise use). The pushing step, referenced as Step (3) in Part 2, has to do with keeping the remote origin synced up with your local Git repository. The stage-and-commit step, referenced as Step (1) in Part 2, is what checkpoints the code.
#* As a general rule, only changes that have been saved (i.e., recorded on disk) can be staged, only changes that have been staged can be committed, and only changes that have been committed can be pushed.
#* In particular, it means that if you have some unsaved changes, then they will not get staged even if you run <tt>git stage</tt> on those files. If you have some non-staged changes, they will not get committed even if you run <tt>git commit</tt>. If you have uncommitted changes, they will not get pushed even if you run <tt>git push</tt>.
#* In a simple scenario where you are working in the master branch and are not doing anything too subtle, your workflow is: save changes, then run these two commands: <pre>
git commit -am "Description of your changes"
git push origin master
</pre>
# Understand the role of staging and committing.
#* Staging a change basically means that you are telling git to record this change in the next commit. You can stage file edits, addition of new files, deletion of files, and renaming of files.
#* It is possible to stage-and-commit together, by using <tt>git commit -a</tt>. The "-a" option tells git to stage all changes to existing files before committing. In fact, many Git users never stage changes explicitly, and simply use "git commit -a" as the default behavior. However, newly added files are not staged by default, and need to be staged by manually running <tt>git add</tt> or <tt>git stage</tt> as discussed later.
#* One reason we want to stage changes explicitly rather than committing them is that we may accidentally start work on multiple changes that should logically be part of separate commits (for instance, you may be making edits to the documentation, to the code, and to the configuration, that you would like to checkpoint separately). In this case, it makes sense to stage all the changes we'd like to put in a particular commit, commit that, then stage the next set of changes, commit that, and so on.
#* Another reason is that there may be some changes we make that we don't want to commit at all, but that we need to make concurrently with other changes that we ''do'' want to commit. For instance, suppose you are making changes to your code, that you are testing by running your code locally. To facilitate debugging, you have set the log-level in the configuration to DEBUG, but you want the log-level in your committed code to always be INFO. You also want to keep committing your changes to the code. In this case, you can keep staging and committing the code files while not staging the file with the log-level configuration, and when you are done with testing you can revert the change to the file with the log-level configuration.

# Understand some more subtleties associated with staging.
#* To tell git to stage a change, you can do <tt>git add</tt> or <tt>git stage</tt> followed by the name of the file. This stages all changes to that file made between the previous commit and the most recently saved version of the file. This means that if you do not do any more staging, then the next time you do a git commit, these changes will get committed.
#* If you make and save changes to a file, stage the file, make and save further changes, and then commit, only the changes made prior to the staging are committed.
#* If you stage a file repeatedly between commits, git does not keep track of previous stagings. In other words, git does not checkpoint uncommitted stages. Rather, outside of commits, git keeps track of only two states: all stagaed changed, and all saved changes. It does not keep track of multiple stages.
#* You may stage multiple files. These will not interfere with one another.
#* You can unstage changes to a file (and revert to the previous commit) by doing <tt>git reset HEAD</tt> followed by the file name. You can unstage all changes by doing <tt>git reset HEAD</tt>. Note that git reset HEAD in and of itself does not actually un''save'' the changes.
#* You can unsave unstaged changes to a file by doing <tt>git checkout -- </tt> followed by the file name.
#* You can unstage and un''save'' all changes (i.e., actually change all files to the way they looked as of the previous commit) by doing <tt>git reset --hard</tt>.

# Know how to see the current git status to get a better sense of what to stage and what to commit.
#* The <tt>git status</tt> command prints out information about the list of files where changes are staged but not committed (this list is printed in green on a color terminal) and the list of files where changes are saved but not staged (this list is printed in red on a color terminal). 
#* In particular, these two lists could potentially overlap. This happens if you make and save changes, then stage them, and then make and save further changes to some of the same files.
#* <tt>git status</tt> does not show the precise changes that were made to the files. You can get a list of saved-but-not-staged changes using <tt>git diff</tt>. To get a list of staged-but-not-committed, use <tt>git diff --staged</tt> (on older versions of Git, you may need to use <tt>git diff --cached</tt>).<ref>[http://stackoverflow.com/questions/1587846/how-do-i-show-the-changes-which-have-been-staged How do I show the changes which have been staged?]</ref>
#* Once you have staged all changes, <tt>git diff</tt> should return nothing. Once you have committed all changes, <tt>git status</tt> should report that your working directory is clean, and <tt>git status --porcelain</tt> should return nothing.
#* If some of the files you added should not be part of the Git repository (for instance, they are compiled files, or they are configuration files local to your system) be sure to add the files, or a subdirectory containing only such files, to the .gitignore. This helps you stay clean.

# Add commit messages when committing! The best way to commit is to use one of these two methods:
#* If you are staging all changes as part of the commit itself: <tt>git commit -am "Description of the changes in your commit"</tt>
#* If you have already staged the changes you want to commit: <tt>git commit -m "Description of the changes in your commit"</tt>

# Whenever you want your changes to be available in the remote origin and to other collaborators, you should push them. A few pointers.
#* The standard pushing command if you are in the master branch is <tt>git push origin master</tt>
#* If you are in another branch, you should do <tt>git push origin branchName</tt>. Branches are discussed later.
#* When you push, you send the remote origin not just your recent commit but all previous commits as well. The HEAD (most recent committed state) of the remote origin will match that of your most recent commit, but the remote origin (and therefore any other repository that clones from or fetches from it subsequently) will have access to previous commits. This is why pushing immediately after committing does not matter too much, and it is also why it is critical to make sure you never commit anything that has sensitive security information.
#* According to some schools of thought, you should pair every commit with a push, so that every local checkpoint is recorded immediately on the remote origin. However, other schools of thought say that you should commit often, but push occasionally.<ref name=seth/> You may set different standards for committing and pushing. For instance, you may set a rule that every commit should at minimum compile, whereas you will push to the remote origin only after the code has been tested. The precise guidelines depend on your use case and the guidelines your team decides.
#* Note that when working collaboratively, i.e., if others are making changes to the remote origin, your push may fail because others have made changes. In this case you need to pull (and if necessary, merge conflicts and commit), and then push again.

=== Using branch, checkout, and merge ===

# You may use git branches to better manage your code changes.

#* '''Branches intended for merging back into master''': One practice often used is to start a git branch whenever working on a new, reasonably nontrivial feature, then keep committing and pushing within that branch, and once the feature is fully tested, merge that branch back into master. The merging step itself might be controlled: not everybody may have permission to merge into master, so the merge is submitted as a pull request, and the administrator approves the merge. Often, the branches are tied to git issues (tickets for feature changes).
#* '''Branches intended as slight modifications of master''': You might create a branch that modifies some configuration settings from master so as to facilitate a use case such as local testing. In this case, your new branch will not have many commits of its own, and will not be merged into master. However, it will regularly be merging in ''from'' master. For instance, a branch that you create that has slightly different configurations for local testing might be used by you sporadically to test recent changes to master; every time you use it this way, you pull in from master.
#* '''Branches that diverge for good''': In this case, the branch leaves the master for good. It may or may not continue to be developed further. In some cases, it may be used simply as an easier checkpoint of an earlier state of the project. In other cases, it may be developed further or even into a separate fork of the repository.

# To create a new branch, with a name that is not currently in use, you can run one of these: <pre>git branch branchName</pre> or <pre>git checkout -b branchName</pre>
#* The first of these commands creates a new branch with that name, but does not switch to it. The second command creates the branch and switches to it.
#* With both commands, the entire current state is transferred to the new branch. This means that the commit history till this point, the set of staged-but-not-committed changes, and the set of saved-but-not-staged changes, all get inherited by the new branch.
#* To switch to an already existing branch in your local repository, do <tt>git checkout branchName</tt>
#* The save-stage-commit-push workflow within a branch is the same as for master. The key difference is that when pushing, you need to use <tt>git push origin branchName</tt> instead of <tt>git push origin master</tt>
#* It is also possible for multiple people to collaborate on the same branch. The first person to create the branch simply does <tt>git push origin branchName</tt>. People who subsequently want to collaborate on that branch must do "git fetch origin branchName</tt> so that their local repository gets that branch, and subsequently they can work on it in the same way as the person who created the branch.

# Understand what happens to stages and commits when switching between branches using <tt>git checkout</tt>
#* Committed changes do not get transferred.
#* However, git attempts to transfer all the staged-but-not-committed changes as well as all the saved-but-not-staged changes. It prints out these files to the terminal. Existing files are printed with a "M" prefix whereas new files are printed with an "A" prefix.
#* If any of the files to which either set of changes applies is different in the two branches, git will throw an error, telling you to commit, stash, or discard your changes to avoid them being overwritten by checkout. If the changes involve adding new files that you have not yet staged, git will print an error about untracked working tree files.

# Once you are working in a separate branch, this reduces the barrier to pushing to the remote origin.
#* If you are making all your changes in master, then pushing incomplete changes to the remote origin can be disruptive to collaborators and confuse any person or automated process that deploys directly to production from the remote origin. If, however, you are in your own branch, then you can push this branch to the remote origin. It will not affect the copy of the master in the remote origin, and therefore not disrupt anything.
#* A problem can arise if different people are using the same name for different local branches. For instance, if everybody uses a branch name called "testing" for their own local testing branches, these can confuse git when they attempt to push the branch to the remote origin. It is therefore good practice to choose adistinctive name, and to push to the remote origin early on to "reserve" the name so that other collaborators don't use the same name accidentally.

# Merge with master (or whatever branch you want to merge into) with caution.
#* It is generally good practice to first update your master from the remote, e.g., using <tt>git checkout master</tt> and then <tt>git pull origin master</tt>
#* It is preferable to first merge in from master into your branch rather than the other way around, so that your local master branch is not corrupted by a bad merge. If you wish, you can create a third branch just for merging, though this is usually overkill.
#* To merge in from master into your branch, do <tt>git checkout branchName</tt> followed by <tt>git merge master</tt>. If you are okay with the default merge edit message, use <tt>git merge --no-edit master</tt>.
#* The merge may execute without conflicts. In this case, Git automaticaly creates a merge commit with the default commit message (or your own edit message if you chose to enter one).
#* Examine the changes and do any further testing to make sure that any changes that occurred to master while you were working on your branch do not interfere with the functionality of what you did. Note that just because Git merges without conflicts does ''not'' imply that the merge is unproblematic: there could be subtle semantic problems introduced by the merge that will become apparent only after you compile, test, or run your code.
#* Once you are confident that your changes are good, do <tt>git checkout master</tt> and <tt>git merge --no-edit branchName</tt>. There should be no conflicts at this time. Now, do <tt>git push origin master</tt>.
#* You may want to delete your branch by doing <tt>git branch -D branchName</tt>, or you may want to preserve it. Note that even if you delete your branch, all its associated commits are preserved if you have merged it into master.
#* When merging, there is an option to "fast-forward" changes that is active by default on the command line. This will effectively avoid creating a separate commit for the merge if it is not necessary, i.e., if the branch being merged into has had no changes to it since the other branch diverged from it. The "merge pull request" option on GitHub by default does ''not'' fast-forward changes, so as to always provide an identifiable commit responsible for the merge.<ref>[http://ariya.ofilabs.com/2013/09/fast-forward-git-merge.html Fast-Forward Git Merge]</ref> As a general rule, fast-forwarding makes sense for short-lived branches but non-fast-forward merges make the commit history easier to understand and more faithful to reality.<ref>[http://stackoverflow.com/questions/2850369/why-does-git-fast-forward-merges-by-default Why does git fast-forward merges by default?]</ref>
#* In some cases, the merge may generate conflicts. This usually happens if both branches have made edits to the same file in a way that Git can't automatically reconcile. Git's default behavior is to replace the file with a file where each of the conflicting sections is marked. You have to manually examine and clear the cnflicts. While this is sometimes easy, it is often easier to just discard the failed merge and manually attempt to understand the sets of changes and figure out how to merge them. In the worst case, the badly merged file can just be overridden by a new, rewritten file. Such manual merges need to be explicitly committed after the merge is completed. Until this commit is done, git is in an "unresolved index" state and does not allow you to switch branches.

=== Understanding pulling and pushing ===

# Understand how git fetch and git pull work.
#* <tt>git fetch origin branchName</tt> fetches the version of the <tt>branchName</tt> branch from the remote origin and stores it under the name <tt>origin/branchName</tt> and can be manipulated in a way similar to local branches. Note that this requires one to be able to connect to the remote server.
#* <tt>git pull origin branchName</tt> is shorthand for the following pair of commands: <tt>git fetch origin branchName</tt>, followed by <tt>git merge origin/branchName</tt>. Note that only the first of these requires connectivity to the remote server. If <tt>git merge origin/branchName</tt> is run in isolation, it does not connect to the remote server, instead simply running the merge from whenever the fetch previously occurred.
#* As with all merge efforts, if there are no changes to merge (i.e., if all changes in the remote are already present locally) then it will print "Already up-to-date."
#* There may, however, be changes to merge and conflicts to resolve, and you need to deal with them the same way as you deal with merges between branches, as described in Step (5) of the previous part.
#* It is generally not good practice to run <tt>git pull origin branchName</tt> if your working directory is unclean, because the pulled-in changes may conflict with uncommitted changes in your working directory.
# Understand how git push works.
#* If you run <tt>git status</tt>, then git will inform you if it notices that your local version of your current branch is ahead of the most recently fetched remote version. Note that git will ''not'' try to fetch a remote version unless explicitly told to do so, so this is based on potentially outdated information. Note also that unpushed changes do not compromise git's evaluation of whether the woring directory is clean.
#* If you run <tt>git push origin branchName</tt>, git attempts to push your changes to the remote origin. At this time, if git discovers that there were changes on the remote origin that are not in your local version, the attempt will be rejected. You would then need to do <tt>git pull</tt> (as described in Step (1)).

== References ==

{{reflist}}
